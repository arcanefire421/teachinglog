<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>📘 教學日誌生成器（v12-Patch2 - 作業串接修復版）</title>
<style>
/* 確保手機相容性及美觀 (CSS) */
body { font-family:"Noto Sans TC","PingFang TC","Microsoft JhengHei",sans-serif;
  background:#f5f7fb;margin:0;padding:12px;color:#222;max-width:520px;margin-left:auto;margin-right:auto;}
h1{text-align:center;font-size:1.5rem;margin:12px 0 14px 0;}
.card{background:#fff;border-radius:12px;padding:12px 10px;margin-bottom:12px;
  box-shadow:0 2px 8px rgba(0,20,50,0.06);}
label{font-weight:600;display:block;margin-top:6px;margin-bottom:2px;}
input,select,textarea{width:100%;padding:8px;border-radius:8px;font-size:1rem;
  border:1px solid #ccc;box-sizing:border-box;margin-top:2px;}
textarea{resize:vertical;font-size:1rem;}
button{background:#2563eb;color:white;border:none;border-radius:8px;padding:9px 12px;
  margin-top:8px;cursor:pointer;font-weight:bold;font-size:1rem;margin-right:6px;}
button.danger{background:#ef4444;}button.green{background:#22c55e;}button.orange{background:#f59e0b;}
.section{border-top:1px solid #e5e7eb;margin-top:8px;padding-top:8px;}
.chip{display:inline-block;padding:6px 10px;border-radius:999px;border:1px solid #cbd5e1;
  margin:4px 3px 3px 0;background:#eef3fc;font-size:0.93rem;cursor:pointer;}
.chip:hover{background:#e2e8f0;}
.output{font-family:"Noto Sans Mono","Consolas",monospace;border-radius:8px;
  line-height:1.6;background:#fff;border:1px solid #e5e7eb;padding:14px 12px;margin-top:10px;
  font-size:1.05rem;white-space:pre-wrap;letter-spacing:0.012em;}
@media (max-width:520px){
  body{padding:4px;}
  .output{font-size:1.09rem;padding:8px 6px;}
  input,select,textarea{font-size:1.01rem;}
}

/* 1. 班級選單三格排版 */
.select-group {
    display: flex;
    gap: 5px;
}
.select-group select {
    width: 33.33%;
    margin-top: 0;
}
.select-group + input {
    margin-top: 5px;
}
/* 3. 按鈕排版 */
.button-row {
    display: flex;
    gap: 5px;
    margin-top: 10px;
}
.button-row button {
    margin-top: 0;
    margin-right: 0;
    flex-grow: 1;
    width: auto; /* 讓 flex-grow 控制寬度 */
}

/* 核取方塊樣式調整 */
.unit-row{
  display: flex; 
  align-items: flex-start; 
  margin-top: 5px;
  line-height: 1.2; 
}
.unit-row input[type=checkbox]{
  width: auto; 
  margin: 2px 5px 0 0; 
  transform: scale(1.1); 
  flex-shrink: 0; 
}
.unit-label{
  flex: 1; 
  display: inline; 
  margin-top: 0;
}

/* 暫存區樣式 */
#progressCache {
    margin-top: 10px;
    border: 1px dashed #2563eb;
    background: #f0f7ff;
    padding: 10px;
    border-radius: 8px;
    max-height: 150px;
    overflow-y: auto;
    font-size: 0.95rem;
}
#progressCache .cache-item {
    margin-bottom: 5px;
    color: #1e40af;
    line-height: 1.3;
}
</style>
</head>
<body>
<h1>📘 教學日誌生成器（v12-Patch2 - 作業串接修復版）</h1>

<div class="card">
  <label>🏫 班級模板</label>
  <div class="select-group">
    <select id="gradeSelect">
      <option>高一</option>
      <option>高二</option>
      <option>高三</option>
    </select>
    <select id="subjectSelect">
      <option>物理</option>
      <option>化學</option>
      <option>生物</option>
      <option>地科</option>
    </select>
    <select id="classTypeSelect">
      <option>進度</option>
      <option>總複習</option>
    </select>
  </div>
  <input id="customClassName" placeholder="或自訂班級名稱（可空白）">
  <button class="green" onclick="addTemplate()">＋新增模板</button>
  <button onclick="fillTemplate()">填入班名</button>
  <button class="danger" onclick="clearTemplates()">全清模板</button>
  <div id="templateList" style="margin-top:5px;"></div>
</div>

<div class="card">
  <label>🗓️ 日期</label>
  <div style="display:flex;gap:7px;flex-wrap:wrap;">
    <input id="dateInput" placeholder="自動今日">
    <button onclick="setToday()">今天</button>
    <button onclick="setTomorrow()">明天</button>
  </div>
</div>

<div class="card">
  <label>📚 科目 / 進度選單</label>
  <select id="subject" onchange="loadBooks()">
    <option value="">--選科目--</option>
    <option value="physics">物理</option>
    <option value="chemistry">化學</option>
    <option value="biology">生物</option>
    <option value="earth">地科</option>
  </select>
  
  <div id="bookArea" class="section">
    </div>
  
  <div id="cacheArea" class="section" style="text-align: center;">
      <button class="orange" onclick="addToCache()">➡️ 存入暫存區</button>
      <button class="danger" onclick="clearCache(true)">🗑️ 清空暫存</button> 
  </div>
  
  <label style="margin-top: 10px;">💾 已選進度暫存區</label>
  <div id="progressCache">目前無暫存進度。</div>
</div>

<div class="card">
  <div class="section">
    <label>📄 頁數</label>
    <input id="pages" placeholder="例：p.45~52">
    <div style="display:flex;gap:5px;flex-wrap:wrap;">
      <span class="chip" onclick="appendPages('p. ')">p. </span>
      <span class="chip" onclick="appendPages('p. 5~8')">p. 5~8</span>
      <span class="chip" onclick="appendPages('p. 10~15')">p. 10~15</span>
      <span class="chip" onclick="appendPages('p. 25~30')">p. 25~30</span>
      <span class="chip" onclick="appendPages('p. 50~55')">p. 50~55</span>
    </div>
  </div>
  <div class="section">
    <label>🧾 小考</label>
    <input id="quiz" placeholder="例：第2章小考">
  </div>
  <div class="section">
    <label>🏠 回家作業</label>
    <textarea id="homework" rows="2" placeholder="例：講義 p.53~55＋習題"></textarea>
    <div id="sentenceChips"></div>
    <input id="newSentence" placeholder="加到常用作業句庫（右鍵刪）">
    <button class="green" onclick="addSentence()">＋句庫</button>
  </div>
</div>

<div class="card">
  <div class="button-row">
    <button class="orange" onclick="generate()">🚀 產生日誌</button>
    <button onclick="copyOutput()">📋 複製</button>
    <button class="danger" onclick="clearAll(true)">🧹 清空</button>
  </div>
  <div id="output" class="output" style="display:none"></div>
</div>

<script src="data.js"></script>

<script>
// ================ JS 變數與輔助函數 ================
let progressCache = JSON.parse(localStorage.getItem('teachingLogCache')) || [];

function saveCache() {
    localStorage.setItem('teachingLogCache', JSON.stringify(progressCache));
    renderCache();
}

function renderCache() {
    const cacheDiv = document.getElementById('progressCache');
    if (progressCache.length === 0) {
        cacheDiv.innerHTML = '目前無暫存進度。';
        return;
    }

    // 將暫存區的進度依路徑重新分組 (因為暫存時是單條儲存)
    const groupedCache = new Map();
    progressCache.forEach(item => {
        const path = item.path;
        if (groupedCache.has(path)) {
            // 避免重複加入 topic
            if (!groupedCache.get(path).includes(item.topic)) {
                 groupedCache.get(path).push(item.topic);
            }
        } else {
            groupedCache.set(path, [item.topic]);
        }
    });

    let html = '';
    groupedCache.forEach((topics, path) => {
        const combinedTopics = topics.join(' ＋ ');
        const pathParts = path.split(' / ');
        const lastPart = pathParts.slice(-1)[0];
        
        // 如果只有一個 topic 且 topic 等於路徑最後一部分（章/節/冊），則只顯示路徑
        const isPathOnly = topics.length === 1 && topics[0] === lastPart;
        
        if (isPathOnly) {
             html += `<div class="cache-item">‧ ${path}</div>`;
        } else {
             html += `<div class="cache-item">‧ ${path} <br> (${combinedTopics})</div>`;
        }
    });
    
    cacheDiv.innerHTML = html;
}

// ============== 核心修改區: addToCache() 移除勾選限制，改為分層級存入 ==============
function addToCache() {
    let itemsToCache = [];
    const checks = document.querySelectorAll("#topicArea input[type=checkbox]:checked");
    
    // 1. 優先處理有勾選重點的情況 (最高層級，最細節)
    if (checks.length > 0) {
        checks.forEach(cb => {
            const path = cb.value; 
            const topic = cb.dataset.topicName; 
            itemsToCache.push({ path: path, topic: topic });
            cb.checked = false; // 清空當前頁面勾選狀態
        });
        console.log(`已將 ${checks.length} 個勾選重點存入暫存區！`);
    } else {
        // 2. 處理沒有勾選重點，但選單有選取的情況
        const subjectSelect = document.getElementById('subject');
        const subjectKey = subjectSelect ? subjectSelect.value : '';
        const subjectName = subjectSelect ? subjectSelect.options[subjectSelect.selectedIndex].text : '';
        const bookSelect = document.getElementById('bookSelect');
        const chapterSelect = document.getElementById('chapterSelect');
        const sectionSelect = document.getElementById('sectionSelect');
        
        const bookName = bookSelect ? bookSelect.value : '';
        const chapterName = chapterSelect ? chapterSelect.value : '';
        const sectionName = sectionSelect ? sectionSelect.value : '';

        let progressPath = '';
        let progressName = '';

        if (subjectKey) {
            if (sectionName) {
                // 2.1. 選到小節: 存入 小節 名稱
                progressPath = `${bookName} / ${chapterName} / ${sectionName}`;
                progressName = sectionName;
                
            } else if (chapterName) {
                // 2.2. 選到章節: 存入 章節 名稱
                progressPath = `${bookName} / ${chapterName}`;
                progressName = chapterName;
                
            } else if (bookName) {
                // 2.3. 選到冊別: 存入 冊別 名稱
                progressPath = `${bookName}`;
                progressName = bookName;
                
            } else {
                // 2.4. 只選到科目 (依照 V11 第 5 點要求，科目如果只選擇了 物理 則輸出物理到暫存區)
                // 強化邏輯：如果只選科目，且該科目有冊別，則將所有冊別名稱作為 path，科目名稱作為 topic 存入
                if (BOOKS[subjectKey]) {
                    Object.keys(BOOKS[subjectKey]).forEach(bName => {
                        // 這裡使用 冊別名 作為 path，科目名作爲 topic，符合輸出要求但避免單純存入科目名。
                        itemsToCache.push({ path: bName, topic: subjectName }); 
                    });
                     if (itemsToCache.length > 0) {
                         console.log(`偵測到只選科目，已將 ${subjectName} 涉及的 ${itemsToCache.length} 個冊別作為進度存入暫存區！`);
                         
                     }
                    // 執行完畢，不需再繼續
                    itemsToCache.forEach(item => {
                        const isDuplicate = progressCache.some(p => p.path === item.path && p.topic === item.topic);
                        if (!isDuplicate) progressCache.push(item);
                    });
                    saveCache(); 
                    return; 
                }
            }
        }
        
        // 3. 將最高層級的選擇加入 toCache 列表
        if (progressPath && progressName) {
            itemsToCache.push({ path: progressPath, topic: progressName });
            console.log(`已將選單最高層級：${progressPath} 存入暫存區！`);
        }
        
        // 4. 如果沒有任何選取 (包括科目)，則提示
        if (itemsToCache.length === 0) {
            console.log("請在上方選單選擇進度，或勾選重點單元。");
            return;
        }
    }

    // 5. 統一寫入暫存區
    let addedCount = 0;
    itemsToCache.forEach(item => {
        const isDuplicate = progressCache.some(p => p.path === item.path && p.topic === item.topic);
        if (!isDuplicate) {
            progressCache.push(item);
            addedCount++;
        }
    });

    if (addedCount > 0) {
        saveCache(); // 保存並重新渲染
        // 如果是多個重點，訊息已在前面輸出
        if (checks.length === 0 && itemsToCache.length === 1) {
             console.log("進度已存入暫存區。");
        } else if (checks.length === 0 && itemsToCache.length > 1) {
             // 處理只選科目的多個冊別情況
        } else {
             // 處理多個重點的情況
        }
    } else if (checks.length > 0) {
        // 有勾選，但都重複
         console.log("您勾選的重點已全部在暫存區中。");
    } else {
        // 有選單選項，但重複
        console.log("您選擇的進度已在暫存區中。");
    }
}


// 增加一個參數以控制是否顯示警示窗
function clearCache(showConfirm = false) {
    if (showConfirm) {
        if (!confirm("確定要清空所有暫存區的進度嗎？")) {
            return;
        }
    }
    progressCache = [];
    saveCache();
    console.log("暫存區已清空！");
}

// 2. 頁數常用選項功能
function appendPages(text) {
  const pagesInput = document.getElementById("pages");
  pagesInput.value = text.trim();
}

// ================ 級聯選單功能 (與 v11 相同) ================
function loadBooks() {
    const subjectKey = document.getElementById('subject').value;
    const bookArea = document.getElementById('bookArea');
    bookArea.innerHTML = '';
    
    if (!subjectKey || !BOOKS[subjectKey]) {
        return;
    }

    const books = Object.keys(BOOKS[subjectKey]);
    if (books.length === 0) return;

    let html = '<label>📖 冊別</label>';
    html += `<select id="bookSelect" onchange="loadChapters()">
                <option value="">--選冊別--</option>
                ${books.map(b => `<option value="${b}">${b}</option>`).join('')}
             </select>`;
    
    html += '<div id="chapterSelectArea" style="margin-top:10px;"></div>';
    html += '<div id="sectionSelectArea" style="margin-top:10px;"></div>';
    html += '<div id="topicArea" style="margin-top:10px;"></div>';

    bookArea.innerHTML = html;
}

function loadChapters() {
    const subjectKey = document.getElementById('subject').value;
    const bookSelect = document.getElementById('bookSelect');
    const bookName = bookSelect ? bookSelect.value : '';

    const chapterArea = document.getElementById('chapterSelectArea');
    chapterArea.innerHTML = '';
    document.getElementById('sectionSelectArea').innerHTML = '';
    document.getElementById('topicArea').innerHTML = ''; 

    if (!bookName) return;

    const chapters = Object.keys(BOOKS[subjectKey][bookName]);
    
    let html = '<label>📑 章節</label>';
    html += `<select id="chapterSelect" onchange="loadSections()">
                <option value="">--選章節--</option>
                ${chapters.map(c => `<option value="${c}">${c}</option>`).join('')}
             </select>`;
    
    chapterArea.innerHTML = html;
}

function loadSections() {
    const subjectKey = document.getElementById('subject').value;
    const bookSelect = document.getElementById('bookSelect');
    const chapterSelect = document.getElementById('chapterSelect');
    const bookName = bookSelect ? bookSelect.value : '';
    const chapterName = chapterSelect ? chapterSelect.value : '';

    const sectionArea = document.getElementById('sectionSelectArea');
    sectionArea.innerHTML = '';
    document.getElementById('topicArea').innerHTML = ''; 
    
    if (!chapterName) return;
    
    const sections = Object.keys(BOOKS[subjectKey][bookName][chapterName]);
    
    let html = '<label>📝 小節</label>';
    html += `<select id="sectionSelect" onchange="loadTopics()">
                <option value="">--選小節--</option>
                ${sections.map(s => `<option value="${s}">${s}</option>`).join('')}
             </select>`;
    
    sectionArea.innerHTML = html;
}

function loadTopics() {
    const subjectKey = document.getElementById('subject').value;
    const bookSelect = document.getElementById('bookSelect');
    const chapterSelect = document.getElementById('chapterSelect');
    const sectionSelect = document.getElementById('sectionSelect');
    
    const bookName = bookSelect ? bookSelect.value : '';
    const chapterName = chapterSelect ? chapterSelect.value : '';
    const sectionName = sectionSelect ? sectionSelect.value : '';
    
    const topicArea = document.getElementById('topicArea');
    topicArea.innerHTML = '';

    if (!sectionName) return;

    const topics = BOOKS[subjectKey][bookName][chapterName][sectionName];

    let html = '<label>✅ 今日進度 (可複選)</label>';
    html += '<div style="max-height: 200px; overflow-y: auto; border: 1px solid #e5e7eb; padding: 8px; border-radius: 8px;">';
    
    topics.forEach((topic, index) => {
        const progressPath = `${bookName} / ${chapterName} / ${sectionName}`;
        const uniqueId = `topic-${sectionName.replace(/\s/g, '_')}-${index}`;
        html += `<div class="unit-row">
                    <input type="checkbox" id="${uniqueId}" value="${progressPath}" data-topic-name="${topic}">
                    <label for="${uniqueId}" class="unit-label">${topic}</label>
                 </div>`;
    });
    
    html += '</div>';
    topicArea.innerHTML = html;
}


function formatDate(date) {
  const d = new Date(date);
  const year = d.getFullYear();
  const month = ('0' + (d.getMonth() + 1)).slice(-2);
  const day = ('0' + d.getDate()).slice(-2);
  return `${year}-${month}-${day}`;
}
function setToday(){
  document.getElementById("dateInput").value = formatDate(new Date());
}
function setTomorrow(){
  const tomorrow = new Date();
  tomorrow.setDate(tomorrow.getDate() + 1);
  document.getElementById("dateInput").value = formatDate(tomorrow);
}

// ================ 模板功能 (移除警示窗) ================
let templates = JSON.parse(localStorage.getItem('teachingLogTemplates')) || [];
function saveTemplates() { localStorage.setItem('teachingLogTemplates', JSON.stringify(templates)); }
function renderTemplates() {
  const list = document.getElementById("templateList");
  list.innerHTML = templates.map((t, i) => 
    `<span class="chip" onclick="applyTemplate('${t}')" oncontextmenu="deleteTemplate(${i}, true); return false;">${t}</span>`
  ).join('');
}
function addTemplate() {
  const grade = document.getElementById("gradeSelect").value || "";
  const type = document.getElementById("classTypeSelect").value || "";
  const subj = document.getElementById("subjectSelect").value || "";
  const custom = document.getElementById("customClassName").value.trim() || "";
  // 修正組合順序為 級別 + 科目 + 類型
  const name = custom || `${grade}${subj}${type}`; 
  if (name && !templates.includes(name)) {
    templates.push(name);
    saveTemplates();
    renderTemplates();
  }
}
function applyTemplate(name) {
  document.getElementById("customClassName").value = name;
}
function deleteTemplate(index, showConfirm = false) {
    if (showConfirm) {
        if (!confirm(`確定刪除模板：${templates[index]} 嗎？`)) {
            return;
        }
    }
    templates.splice(index, 1);
    saveTemplates();
    renderTemplates();
    console.log(`模板已刪除。`);
}
function fillTemplate() {
  const className = (() => {
    const grade = document.getElementById("gradeSelect").value || "";
    const type = document.getElementById("classTypeSelect").value || "";
    const subj = document.getElementById("subjectSelect").value || "";
    const custom = document.getElementById("customClassName").value.trim();
    if (custom) return custom;
    // 修正組合順序為 級別 + 科目 + 類型
    const combo = grade + subj + type;
    return combo; 
  })();
  document.getElementById("customClassName").value = className;
}
function clearTemplates(showConfirm = false) {
    if (showConfirm) {
        if (!confirm("確定清空所有班級模板嗎？")) {
            return;
        }
    }
    templates = [];
    saveTemplates();
    renderTemplates();
    console.log("所有班級模板已清空。");
}
renderTemplates();

// ================ 作業句庫功能 (v12-Patch2: 修正 appendHomework 語法錯誤) ================
let sentences = JSON.parse(localStorage.getItem('homeworkSentences')) || ["講義 p.X~Y", "習題卷", "考卷訂正", "複習指定範圍"];
function saveSentences() { localStorage.setItem('homeworkSentences', JSON.stringify(sentences)); }
function renderSentences() {
  const list = document.getElementById("sentenceChips");
  list.innerHTML = sentences.map((s, i) => 
    `<span class="chip" onclick="appendHomework('${s}')" oncontextmenu="deleteSentence(${i}, true); return false;">${s}</span>`
  ).join('');
}
function addSentence() {
  const newS = document.getElementById("newSentence").value.trim();
  if (newS && !sentences.includes(newS)) {
    sentences.push(newS);
    saveSentences();
    renderSentences();
    document.getElementById("newSentence").value = '';
  }
}

// *** 修復後的 appendHomework 函數 (V12-Patch2 核心修改) ***
function appendHomework(s) {
  const homework = document.getElementById("homework");
  if (homework.value.trim() === '') {
    homework.value = s;
  } else if (!homework.value.includes(s)) {
    // 修正了 homework.endsWith() 錯誤，現在改為 homework.value.endsWith()
    homework.value += (homework.value.endsWith('。') || homework.value.endsWith('、') || homework.value.endsWith('！') || homework.value.endsWith('？') ? '' : '＋') + s;
  }
}
// *************************************************

function deleteSentence(index, showConfirm = false) {
    if (showConfirm) {
        if (!confirm(`確定刪除句庫：${sentences[index]} 嗎？`)) {
            return;
        }
    }
    sentences.splice(index, 1);
    saveSentences();
    renderSentences();
    console.log("句庫項目已刪除。");
}
renderSentences();

// ================ 產生日誌功能 (v12-Patch1 優化，無功能變動) ================
function generate() {
    // 1. 抓取所有值並進行 trim()
    const customClassName = document.getElementById("customClassName").value.trim();
    const date = document.getElementById("dateInput").value.trim();
    const pages = document.getElementById("pages").value.trim();
    const quiz = document.getElementById("quiz").value.trim();
    const homework = document.getElementById("homework").value.trim();
    
    // 1.1. 檢查是否有當前選中的重點：自動存入暫存區 (不給提示)
    const currentChecks = document.querySelectorAll("#topicArea input[type=checkbox]:checked");
    let tempCacheFromChecks = [];
    if (currentChecks.length > 0) {
        console.log(`偵測到 ${currentChecks.length} 個勾選重點，自動存入暫存區。`);
        currentChecks.forEach(cb => {
            const path = cb.value; 
            const topic = cb.dataset.topicName; 
            const newItem = { path: path, topic: topic };
            
            // 檢查是否已存在 (避免重複加入)
            const isDuplicate = progressCache.some(item => item.path === path && item.topic === topic);

            if (!isDuplicate) {
                progressCache.push(newItem);
            }
            cb.checked = false; // 清空當前頁面勾選狀態
        });
        saveCache(); // 保存並重新渲染暫存區
    }

    const className = (() => {
        if (customClassName) return customClassName;
        const grade = document.getElementById("gradeSelect").value || "";
        const type = document.getElementById("classTypeSelect").value || "";
        const subj = document.getElementById("subjectSelect").value || "";
        // 修正組合順序為 級別 + 科目 + 類型
        const combo = grade + subj + type;
        return combo.trim();
    })(); 

    // 2. 處理進度：優先使用暫存區 (progressCache) 中的數據
    
    let progressToOutput = []; // 儲存最終要輸出的進度項目
    
    if (progressCache.length > 0) {
        // 2.1. A. 暫存區有資料：使用暫存區 (progressCache)
        progressToOutput = [...progressCache]; // 複製一份，避免直接修改
        console.log("進度來源：暫存區");
    } else {
        // 2.1. B. 暫存區無資料：嘗試從選單中抓取最高層級進度 (同 addToCache 邏輯，避免重複)
        const subjectSelect = document.getElementById('subject');
        const subjectKey = subjectSelect ? subjectSelect.value : '';
        const subjectName = subjectSelect ? subjectSelect.options[subjectSelect.selectedIndex].text : '';
        const bookSelect = document.getElementById('bookSelect');
        const chapterSelect = document.getElementById('chapterSelect');
        const sectionSelect = document.getElementById('sectionSelect');
        
        const bookName = bookSelect ? bookSelect.value : '';
        const chapterName = chapterSelect ? chapterSelect.value : '';
        const sectionName = sectionSelect ? sectionSelect.value : '';

        let progressPath = '';
        let progressName = '';

        if (sectionName) {
            // 選到小節 (最高層級：小節)
            progressPath = `${bookName} / ${chapterName} / ${sectionName}`;
            progressName = sectionName;
            
        } else if (chapterName) {
            // 只選到章節 (最高層級：章節)
            progressPath = `${bookName} / ${chapterName}`;
            progressName = chapterName;
            
        } else if (bookName) {
            // 只選到冊別 (最高層級：冊別)
            progressPath = `${bookName}`;
            progressName = bookName;
            
        } else if (subjectKey) {
            // 只選科目: 輸出科目名稱
            // 由於這時沒有明確的 path，為了輸出，我們取所有冊別作為 path，科目名作為 topic
            if (BOOKS[subjectKey]) {
                Object.keys(BOOKS[subjectKey]).forEach(bName => {
                     progressToOutput.push({ path: bName, topic: subjectName }); 
                });
            }
            console.log("進度來源：選單 (只選科目)");
        }
        
        // 將最高層級的單一選擇加入 output 列表
        if (progressPath && progressName) {
             progressToOutput.push({ path: progressPath, topic: progressName });
             console.log("進度來源：選單 (最高層級)");
        }
        
    }
    
    // 2.2. 將進度依路徑重新分組 (不論來源是暫存區還是自動抓取)
    const groupedProgress = new Map();
    progressToOutput.forEach(item => {
      const path = item.path;
      const topic = item.topic || path.split(' / ').pop(); // 如果沒有 topic，使用路徑的最後一部分
      
      if (groupedProgress.has(path)) {
        if (!groupedProgress.get(path).includes(topic)) {
             groupedProgress.get(path).push(topic);
        }
      } else {
        groupedProgress.set(path, [topic]);
      }
    });

    const progressLines = [];
    
    // 2.3. 遍歷 Map 輸出，使用緊湊格式
    groupedProgress.forEach((topics, path) => {
      // 輸出格式: ‧ 冊別 / 章節 / 小節 (重點1 ＋ 重點2)
      const combinedTopics = topics.join(' ＋ ');
      const parts = path.split(' / ');
      const lastPart = parts.slice(-1)[0];
      
      // 判斷是否為「單一」進度，且重點名稱與路徑末端名稱相同 (或為只選科目的情況)
      const isSingleMatch = (topics.length === 1 && (topics[0] === lastPart || topics[0] === document.getElementById('subject').options[document.getElementById('subject').selectedIndex].text));

      if (isSingleMatch) {
         progressLines.push(`‧ ${path}`);
      } else {
         progressLines.push(`‧ ${path} (${combinedTopics})`);
      }
      
    });

    const progressOutput = progressLines.join('\n');


    // 3. 組合最終結果 (空值完全不顯示區塊，區塊間只有一個換行符)
    let result = [];

    // 班級
    if (className) {
        result.push(`🏫 班級\n${className}`);
    }

    // 日期
    if (date) {
        result.push(`🗓️ 日期\n${date}`);
    }

    // 進度 (從暫存區或選單取出，可空)
    if (progressOutput) {
        result.push(`📘 今日進度\n${progressOutput}`);
    }

    // 頁數
    if (pages) {
        result.push(`📄 頁數\n${pages}`);
    }

    // 小考
    if (quiz) {
        result.push(`🧾 小考\n${quiz}`);
    }

    // 作業
    if (homework) {
        result.push(`🏠 作業\n${homework}`);
    }
    
    // 4. 輸出
    const out = document.getElementById("output");
    out.style.display="block";
    // 使用 \n 分隔每個區塊 (實現區塊間無空行)
    out.textContent = result.join('\n').trim(); 
    out.scrollIntoView({behavior:"smooth"});
    
    // 產生後清空暫存區
    if (progressCache.length > 0) {
        // 只要使用了暫存區的內容，就清空
        progressCache = [];
        saveCache(); // 清空並保存
    }
}


function copyOutput(){
    const text=document.getElementById("output").textContent;
    if(!text) {
        console.log("請先產生內容");
        return;
    }
    navigator.clipboard.writeText(text).then(() => {
        console.log("已複製到剪貼簿！"); // 使用 console.log 替代 alert
    }).catch(err => {
        console.error('複製失敗:', err);
    });
}

// 增加一個參數以控制是否顯示警示窗
function clearAll(showConfirm = false){
    if (showConfirm) {
        if (!confirm("確定清空所有輸入框內容與暫存區嗎？")) {
            return;
        }
    }
    document.getElementById("dateInput").value = "";
    document.getElementById("bookArea").innerHTML = ""; 
    document.getElementById("pages").value = "";
    document.getElementById("quiz").value = "";
    document.getElementById("homework").value = "";
    document.getElementById("customClassName").value = "";
    document.getElementById("output").textContent = "";
    document.getElementById("output").style.display="none";
    
    // 清空暫存區 (無警示窗)
    progressCache = [];
    saveCache();
    
    console.log("所有內容已清空！");
}

// 初始化時設定今日日期並渲染暫存區
document.addEventListener('DOMContentLoaded', () => {
    if (!document.getElementById("dateInput").value) {
        setToday();
    }
    renderCache();
});
</script>

</body>
</html>